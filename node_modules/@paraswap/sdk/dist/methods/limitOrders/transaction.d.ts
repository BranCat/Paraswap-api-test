import type { ConstructFetchInput, OptimalRate } from '../../types';
import { BuildLimitOrderTxInput, BuildOptions, BuildSwapAndLimitOrderTxInput, TransactionParams } from '../swap/transaction';
import { GetRateInput } from '../swap/rates';
import type { OrderData } from './buildOrder';
declare type MinBuildSwapAndLimitOrderTxInput = Omit<BuildSwapAndLimitOrderTxInput, 'srcToken' | 'srcAmount' | 'destToken' | 'destDecimals'>;
declare type BuildSwapAndLimitOrdersTx = (params: MinBuildSwapAndLimitOrderTxInput, options?: BuildOptions, signal?: AbortSignal) => Promise<TransactionParams>;
declare type MinBuildLimitOrderTxInput = Omit<BuildLimitOrderTxInput, 'srcToken' | 'srcAmount' | 'destToken' | 'slippage'>;
declare type BuildLimitOrdersTx = (params: MinBuildLimitOrderTxInput, options?: BuildOptions, signal?: AbortSignal) => Promise<TransactionParams>;
export declare type BuildLimitOrdersTxFunctions = {
    getLimitOrdersRate: GetLimitOrdersRate;
    buildLimitOrderTx: BuildLimitOrdersTx;
    buildSwapAndLimitOrderTx: BuildSwapAndLimitOrdersTx;
};
declare type GetLimitOrdersRate = (options: Omit<GetRateInput, 'amount' | 'side'> & {
    amount?: string;
}, orders: CheckableOrderData[], signal?: AbortSignal) => Promise<OptimalRate>;
export declare const constructBuildLimitOrderTx: ({ apiURL, chainId, fetcher, }: ConstructFetchInput) => BuildLimitOrdersTxFunctions;
declare type CheckableOrderData = Pick<OrderData, 'takerAsset' | 'makerAsset' | 'takerAmount' | 'maker'> & {
    taker?: OrderData['taker'];
};
export {};
//# sourceMappingURL=transaction.d.ts.map