import type { ConstructFetchInput, OptimalRate } from '../../types';
import { BuildNFTOrderTxInput, BuildOptions, BuildSwapAndNFTOrderTxInput, TransactionParams } from '../swap/transaction';
import { GetRateInput } from '../swap/rates';
import type { NFTOrderData } from './buildOrder';
declare type MinBuildSwapAndNFTOrderTxInput = Omit<BuildSwapAndNFTOrderTxInput, 'srcToken' | 'srcAmount' | 'destToken' | 'destDecimals'>;
declare type BuildSwapAndNFTOrdersTx = (params: MinBuildSwapAndNFTOrderTxInput, options?: BuildOptions, signal?: AbortSignal) => Promise<TransactionParams>;
declare type MinBuildNFTOrderTxInput = Omit<BuildNFTOrderTxInput, 'srcToken' | 'srcAmount' | 'destToken' | 'slippage'>;
declare type BuildNFTOrdersTx = (params: MinBuildNFTOrderTxInput, options?: BuildOptions, signal?: AbortSignal) => Promise<TransactionParams>;
export declare type BuildNFTOrdersTxFunctions = {
    getNFTOrdersRate: GetNFTOrdersRate;
    buildNFTOrderTx: BuildNFTOrdersTx;
    buildSwapAndNFTOrderTx: BuildSwapAndNFTOrdersTx;
};
declare type GetNFTOrdersRate = (options: Omit<GetRateInput, 'amount' | 'side'> & {
    amount?: string;
}, orders: CheckableOrderData[], signal?: AbortSignal) => Promise<OptimalRate>;
export declare const constructBuildNFTOrderTx: ({ apiURL, chainId, fetcher, }: ConstructFetchInput) => BuildNFTOrdersTxFunctions;
declare type CheckableOrderData = Pick<NFTOrderData, 'takerAsset' | 'makerAsset' | 'takerAmount' | 'maker'> & {
    taker?: NFTOrderData['taker'];
};
export {};
//# sourceMappingURL=transaction.d.ts.map