import type { Address } from '../../../types';
import type { AssetTypeVariant } from './types';
import { Domain } from '../../common/orders/buildOrderData';
declare const OrderNFT: {
    name: string;
    type: string;
}[];
export interface BuildNFTOrderDataInput {
    chainId: number;
    verifyingContract: Address;
    nonce?: number;
    expiry: number;
    makerAsset: Address;
    takerAsset: Address;
    makerAmount: string;
    takerAmount: string;
    /** @description NFT Token id, will default to 0 (ERC20), provide for NFT */
    makerAssetId: string;
    /** @description NFT Token id, will default to 0 (ERC20), provide for NFT */
    takerAssetId?: string;
    /** @description Token type: ERC20 = 0, ERC1155 = 1, ERC721 = 2 */
    makerAssetType: AssetTypeVariant;
    /** @description Token type: ERC20 = 0, ERC1155 = 1, ERC721 = 2 */
    takerAssetType: AssetTypeVariant;
    maker: Address;
    taker?: Address;
    AugustusAddress: Address;
}
export declare type SignableNFTOrderData = {
    types: {
        OrderNFT: typeof OrderNFT;
    };
    domain: Domain;
    data: NFTOrderData;
};
export declare type BigIntAsString = string;
export declare type NFTOrderData = {
    expiry: number;
    makerAmount: BigIntAsString;
    makerAsset: BigIntAsString;
    makerAssetId: BigIntAsString;
    takerAmount: BigIntAsString;
    takerAsset: BigIntAsString;
    takerAssetId: BigIntAsString;
    nonceAndMeta: BigIntAsString;
    maker: Address;
    taker: Address;
};
export declare function buildOrderData({ chainId, verifyingContract, nonce, expiry, makerAsset: _makerAssetAddress, takerAsset: _takerAssetAddress, makerAmount, takerAmount, makerAssetId, takerAssetId, makerAssetType, takerAssetType, maker, AugustusAddress, taker: takerInNonce, }: BuildNFTOrderDataInput): SignableNFTOrderData;
export declare function assetAddressToUint(assetAddress: Address, assetType: AssetTypeVariant): BigIntAsString;
export {};
//# sourceMappingURL=buildOrderData.d.ts.map