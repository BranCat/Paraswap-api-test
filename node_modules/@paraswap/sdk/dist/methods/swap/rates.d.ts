import { SwapSide, ContractMethod } from '../../constants';
import type { ConstructFetchInput, Address, AddressOrSymbol, PriceString, OptimalRate } from '../../types';
export declare enum PricingMethod {
    megapath = "megapath",
    multipath = "multipath",
    simplepath = "simplepath"
}
export declare type RateOptions = {
    excludeDEXS?: string[];
    includeDEXS?: string[];
    excludePools?: string[];
    excludePricingMethods?: PricingMethod[];
    excludeContractMethods?: ContractMethod[];
    includeContractMethods?: ContractMethod[];
    adapterVersion?: string;
    partner?: string;
    maxImpact?: number;
    maxUSDImpact?: number;
    otherExchangePrices?: boolean;
};
declare type CommonGetRateInput = {
    amount: PriceString;
    userAddress?: Address;
    side?: SwapSide;
    options?: RateOptions;
    srcDecimals?: number;
    destDecimals?: number;
};
export declare type GetRateInput = CommonGetRateInput & {
    srcToken: AddressOrSymbol;
    destToken: AddressOrSymbol;
};
export declare type GetRate = (options: GetRateInput, signal?: AbortSignal) => Promise<OptimalRate>;
declare type GetRateByRouteInput = CommonGetRateInput & {
    route: AddressOrSymbol[];
};
declare type GetRateByRoute = (options: GetRateByRouteInput, signal?: AbortSignal) => Promise<OptimalRate>;
export declare type GetRateFunctions = {
    getRate: GetRate;
    getRateByRoute: GetRateByRoute;
};
export declare const constructGetRate: ({ apiURL, chainId, fetcher, }: ConstructFetchInput) => GetRateFunctions;
export {};
//# sourceMappingURL=rates.d.ts.map