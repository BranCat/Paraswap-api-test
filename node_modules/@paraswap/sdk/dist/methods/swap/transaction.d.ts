import type { WithGasPrice, WithMaxFee } from '../../gas';
import type { ConstructFetchInput, Address, PriceString, OptimalRate } from '../../types';
import type { OrderData } from '../limitOrders/buildOrder';
import { AssetTypeVariant } from '../nftOrders/helpers/types';
export interface TransactionParams {
    to: string;
    from: string;
    value: string;
    data: string;
    gasPrice: string;
    gas?: string;
    chainId: number;
}
export declare type SwappableOrder = OrderData & {
    permitMakerAsset?: string;
    signature: string;
};
export declare type SwappableNFTOrder = SwappableOrder & {
    makerAssetId: string;
    takerAssetId: string;
    makerAssetType: AssetTypeVariant;
    takerAssetType: AssetTypeVariant;
};
export declare type TxInputAmountsPartSell = {
    slippage: number;
    srcAmount: PriceString;
    destAmount?: never;
};
export declare type TxInputAmountsPartBuy = {
    slippage: number;
    srcAmount?: never;
    destAmount: PriceString;
};
export declare type TxInputAmountsPartBuyOrSell = {
    slippage?: never;
    srcAmount: PriceString;
    destAmount: PriceString;
};
export declare type BuildTxInputBase = {
    srcToken: Address;
    destToken: Address;
    userAddress: Address;
    /** @description used with referral link */
    referrer?: string;
    partner?: string;
    partnerAddress?: string;
    partnerFeeBps?: number;
    receiver?: Address;
    srcDecimals?: number;
    destDecimals?: number;
    permit?: string;
    deadline?: string;
};
export declare type BuildSwapTxInput = BuildTxInputBase & {
    priceRoute: OptimalRate;
} & (TxInputAmountsPartSell | TxInputAmountsPartBuy | TxInputAmountsPartBuyOrSell);
declare type BuildTxInputBaseBUYForOrders<K extends keyof TxInputAmountsPartBuy | keyof BuildTxInputBase = never> = Omit<BuildTxInputBase, K> & (Omit<TxInputAmountsPartBuy, 'destAmount' | K> | Omit<TxInputAmountsPartBuyOrSell, 'destAmount' | K>);
export declare type BuildLimitOrderTxInput = BuildTxInputBaseBUYForOrders & {
    orders: SwappableOrder[];
    srcDecimals: number;
    destDecimals: number;
};
export declare type BuildNFTOrderTxInput = BuildTxInputBaseBUYForOrders<'destDecimals'> & {
    orders: SwappableNFTOrder[];
    srcDecimals: number;
};
export interface BuildSwapAndLimitOrderTxInput0 extends Omit<BuildTxInputBase, 'destAmount'> {
    priceRoute: OptimalRate;
    orders: SwappableOrder[];
    destDecimals: number;
}
export declare type BuildSwapAndLimitOrderTxInput = BuildTxInputBaseBUYForOrders & {
    priceRoute: OptimalRate;
    orders: SwappableOrder[];
    destDecimals: number;
};
export declare type BuildSwapAndNFTOrderTxInput = BuildTxInputBaseBUYForOrders & {
    priceRoute: OptimalRate;
    orders: SwappableNFTOrder[];
};
export declare type BuildTxInput = BuildSwapTxInput | BuildLimitOrderTxInput | BuildNFTOrderTxInput | BuildSwapAndLimitOrderTxInput | BuildSwapAndNFTOrderTxInput;
export declare type BuildOptionsBase = {
    ignoreChecks?: boolean;
    ignoreGasEstimate?: boolean;
    onlyParams?: boolean;
    simple?: boolean;
};
export declare type BuildOptionsWithGasPrice = BuildOptionsBase & Partial<WithGasPrice>;
export declare type BuildOptionsWitWithMaxFee = BuildOptionsBase & Partial<WithMaxFee>;
export declare type BuildOptions = BuildOptionsWithGasPrice | BuildOptionsWitWithMaxFee;
declare type BuildTx = (params: BuildTxInput, options?: BuildOptions, signal?: AbortSignal) => Promise<TransactionParams>;
export declare type BuildTxFunctions = {
    buildTx: BuildTx;
};
export declare const constructBuildTx: ({ apiURL, chainId, fetcher, }: ConstructFetchInput) => BuildTxFunctions;
export {};
//# sourceMappingURL=transaction.d.ts.map