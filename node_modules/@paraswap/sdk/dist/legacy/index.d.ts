import type Web3 from 'web3';
import type { SendOptions } from 'web3-eth-contract';
import type { ContractTransaction } from '@ethersproject/contracts';
import { SwapSide } from '../constants';
import { SwapSDKMethods, PriceString, Address, OptimalRate } from '..';
import { Web3UnpromiEvent, EthersProviderDeps } from '../helpers';
import type { RateOptions } from '../methods/swap/rates';
import type { BuildOptions, TransactionParams } from '../methods/swap/transaction';
import type { AddressOrSymbol, Token, FetcherFunction } from '../types';
import type { Allowance } from '../methods/swap/balance';
import type { AxiosRequirement } from '../helpers/fetchers/axios';
export declare type APIError = {
    message: string;
    status?: number;
    data?: any;
};
declare type Fetch = typeof fetch;
declare type TxResponse = Web3UnpromiEvent | ContractTransaction;
declare type LegacyOptions = {
    chainId?: number;
    apiURL?: string;
    web3Provider?: Web3;
    ethersDeps?: EthersProviderDeps;
    account?: Address;
    axios?: AxiosRequirement;
    fetch?: Fetch;
};
/** @deprecated */
export declare class ParaSwap {
    sdk: Partial<SwapSDKMethods<TxResponse>>;
    fetcher: FetcherFunction;
    chainId: number;
    apiURL: string;
    web3Provider?: Web3;
    ethersDeps?: EthersProviderDeps;
    account?: Address;
    constructor({ chainId, apiURL, web3Provider, ethersDeps, account, axios, fetch, }: LegacyOptions);
    private static handleAPIError;
    private static extractHashFromTxResponse;
    setWeb3Provider(web3Provider: Web3, account?: string): this;
    setEthersProvider(ethersDeps: EthersProviderDeps, account?: string): this;
    getTokens(): Promise<Token[] | APIError>;
    getAdapters(): Promise<APIError | {
        [x: string]: {
            adapter: string;
            index: number;
        }[];
    }>;
    getRateByRoute(route: AddressOrSymbol[], amount: PriceString, userAddress?: Address, side?: SwapSide, options?: RateOptions, srcDecimals?: number, destDecimals?: number): Promise<OptimalRate | APIError>;
    getRate(srcToken: AddressOrSymbol, destToken: AddressOrSymbol, amount: PriceString, userAddress?: Address, side?: SwapSide, options?: RateOptions, srcDecimals?: number, destDecimals?: number): Promise<OptimalRate | APIError>;
    buildTx(srcToken: Address, destToken: Address, srcAmount: PriceString, destAmount: PriceString, priceRoute: OptimalRate, userAddress: Address, partner?: string, partnerAddress?: string, partnerFeeBps?: number, receiver?: Address, options?: BuildOptions, srcDecimals?: number, destDecimals?: number, permit?: string, deadline?: string): Promise<TransactionParams | APIError>;
    getTokenTransferProxy(_provider?: any): Promise<Address | APIError>;
    getAllowances(userAddress: Address, tokenAddresses: Address[]): Promise<Allowance[] | APIError>;
    getAllowance(userAddress: Address, tokenAddress: Address): Promise<Allowance | APIError>;
    approveTokenBulk(amount: PriceString, userAddress: Address, tokenAddresses: Address[], 
    /** @deprecated */
    _provider?: any): Promise<string[] | APIError>;
    approveToken(amount: PriceString, userAddress: Address, tokenAddress: Address, 
    /** @deprecated */
    _provider?: any, // not used, can't detect if Ethers or Web3 provider without importing them
    sendOptions?: Omit<SendOptions, 'from'>): Promise<string | APIError>;
    getMarketNames(): Promise<string[] | APIError>;
    getBalance(userAddress: Address, token: AddressOrSymbol): Promise<Token | APIError>;
    getBalances(userAddress: Address): Promise<Token[] | APIError>;
}
export {};
//# sourceMappingURL=index.d.ts.map