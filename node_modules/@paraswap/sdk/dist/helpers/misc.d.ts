import type { Contract as EthersContract, ContractFunction as EthersContractFunction, PopulatedTransaction as EthersPopulatedTransaction, BigNumber as EthersBigNumber } from 'ethers';
import type { ContractSendMethod as Web3ContractSendMethod, Contract as Web3Contract } from 'web3-eth-contract';
import { Primitive } from 'ts-essentials';
import type { AxiosError } from 'axios';
export declare type EthersContractWithMethod<T extends string> = EthersContract & {
    readonly [method in T]: EthersContractFunction;
} & {
    readonly functions: {
        [method in T]: EthersContractFunction;
    };
    readonly callStatic: {
        [method in T]: EthersContractFunction;
    };
    readonly estimateGas: {
        [method in T]: EthersContractFunction<EthersBigNumber>;
    };
    readonly populateTransaction: {
        [method in T]: EthersContractFunction<EthersPopulatedTransaction>;
    };
};
export declare function ethersContractHasMethods<T extends string>(contract: EthersContract, ...methods: T[]): contract is EthersContractWithMethod<T>;
export declare function assertEthersContractHasMethods<T extends string>(contract: EthersContract, ...methods: T[]): asserts contract is EthersContractWithMethod<T>;
export declare type Web3ContractWithMethod<T extends string> = Web3Contract & {
    methods: {
        [method in T]: Web3ContractSendMethod;
    };
};
export declare function web3ContractHasMethods<T extends string>(contract: Web3Contract, ...methods: T[]): contract is Web3ContractWithMethod<T>;
export declare function assertWeb3ContractHasMethods<T extends string>(contract: Web3Contract, ...methods: T[]): asserts contract is Web3ContractWithMethod<T>;
export declare const objectToFilledEntries: <T extends Record<string, unknown>>(object: T) => [string, string][];
export declare const constructSearchString: <U extends Record<string, Primitive>>(queryOptions: U) => `?${string}` | '';
declare type FetcherErrorConstructorInput = Pick<AxiosError, 'code' | 'request' | 'response' | 'isAxiosError' | 'message'>;
export interface FetcherErrorInterface extends FetcherErrorConstructorInput {
    status?: number;
    code?: string;
}
export declare const isFetcherError: (error: unknown) => error is FetcherError;
export declare class FetcherError extends Error implements FetcherErrorInterface {
    code: string | undefined;
    status: number | undefined;
    request: any;
    response: import("axios").AxiosResponse<unknown, any> | undefined;
    isAxiosError: boolean;
    constructor({ code, request, response, isAxiosError, message, }: FetcherErrorConstructorInput);
}
export declare function isDataWithError(data: unknown): data is {
    error: string;
};
export declare type ExtractAbiMethodNames<T extends readonly {
    name: string;
}[]> = T[number]['name'];
export declare function gatherObjectsByProp<T>(elements: T[], pickProp: (elem: T, index: number) => string): Record<string, T>;
export declare function gatherObjectsByProp<T, U>(elements: T[], pickProp: (elem: T, index: number) => string, transfrom: (elem: T, accumElem: U | undefined, index: number) => U): Record<string, U>;
export declare const isFilledArray: <T>(array: T[]) => array is [T, ...T[]];
export declare function getRandomInt(): number;
export declare function runOnceAndCache<T, Args extends any[]>(func: (...args: Args) => NonNullable<T>): (...args: Args) => NonNullable<T>;
export {};
//# sourceMappingURL=misc.d.ts.map